<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structure</title>
    <link href="css/style.css" type="text/css" rel="stylesheet">
</head>

<body>
    <div class="body">
        <h2>Data Structure</h2>


        <h3>1.1 Algorithm Running times</h3>
        <pre><code class="code-html">
O(n!)   - factorial complexity
O(C<sup>n</sup>)   - exponential complexity, C - constant
O(n<sup>k</sup>)   - polynomial , k&gt;1
O(N*logN)   -linearithmatic complexity
O(N)    - linear time complexity
O(logN) - logarithmic complexity
O(1)    - constant time complexity
</code></pre>

        <h3>1.2 Complexity classes</h3>
        <pre><code class="code-html">
# Polynomial (P)
<i>polynomial amount of time needed to solve.</i>
<i>not all this problems have practical appliations , eg: bubblesort</i>

# Non-deterministic polynomial (NP)
<i>If we have a certain solution for the problem then we can verify the solution in polynomial Time.</i>
<i>P is in NP</i>
<i>problem P=NP ? in future it may happen</i>
<i>Eg : Integer factorization (verfication is simple) , knapsack problem</i>

# NP-complete 
<i>Hardest problem in NP</i>
<i>Can transform NP-C to NP in P time (use Karp-reduction)</i>
<i>If we manage to to find a polynomial algorithm for NP-C problem then it means P=NP</i>
<i>Eg : Graph coloring</i>

# NP-hard
<i>Problem that are atleast hard as the problem in NP class</i>
<i>Can transform NP-H to NP-C in P time(use Karp-reduction)</i>
<i>Eg : Halting problem , Travelling salesman problem</i>
</code></pre>


<h3>2.1 O(N)    - linear time complexity</h3>
<pre><code class="code-html">
    class LinearTimeComplexity {

        public static int getFirst(int[] nums) {
            return nums[0];
        }
    
        public static void main(String[] args) {
    
            int[] numbers = new int[10000000];
    
            for (int i = 0; i &lt; numbers.length; i++)
                numbers[i] = i;
    
            long start = System.currentTimeMillis();
            getFirst(numbers);
            System.out.println("Time taken : " + (System.currentTimeMillis() - start));
    
        }
    }
</code></pre>

<h3>2.2 O(logN) - logarithmic complexity</h3>
<pre><code class="code-html">
    class BinarySearch {

        static int[] numbers = new int[10000000];
    
        public static int search(int[] nums, int item) {
            int left = 0;
            int right = nums.length - 1;
    
            while (left &lt;= right) {
                int middle = (left + right) / 2;
    
                if (nums[middle] == item)
                    return middle;
                if (nums[middle] &lt; item)
                    left = middle + 1;
                else
                    right = middle - 1;
    
            }
    
            return -1;
        }
    
        public static void main(String[] args) {
    
            for (int i = 0; i &lt; numbers.length; i++)
                numbers[i] = i;
    
            long start = System.currentTimeMillis();
            System.out.println("Find ? " + search(numbers, 3454));
            System.out.println("Time taken : " + (System.currentTimeMillis() - start));
    
        }
    }
</code></pre>

<h3>2.3 O(N)   - linear time complexity</h3>
<pre><code class="code-html">
    <i>Linear Search</i>

</code></pre>
<h3>2.4 O(N*N)   - linear time complexity</h3>
<pre><code class="code-html">
    <i>Bubble Sort</i>
    
</code></pre>

<h3>3.1 Importance of DS</h3>
<pre><code class="code-html">
    <i>Dijkstra's algorithm (shortest path in a G(V,E)) - O(N<sup>2</sup>)</i>
    <i>with priority queues(heaps) - O(NlogN)</i>

    <i>Kruskal's algorithm (spanning tree in a G(V,E)) - O(E logV)</i>
    <i>with priority queues(heaps) - O(E+logV)</i>
    
</code></pre>

    </div>
</body>

</html>